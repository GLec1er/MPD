async def update_cache_likes_in_redis(post_id):
    """
    Поддерживает актуальность лайков в кэше
    """
    key = f"likes:{post_id}"
    current_likes = await redis.get(key)

    if current_likes is None:
        new_likes = 1
    else:
        new_likes = int(current_likes) + 1

    await redis.set(key, new_likes, ex=300)
    return new_likes


# ПРОБЛЕМЫ КОДА

#1. Атомарность операций:

# В данном коде операция "получить -> обновить -> записать" не является атомарной.
# Это значит, что между тем, как значение было получено (redis.get), и тем, как оно было обновлено (redis.set),
# может произойти другой запрос, который также попытается обновить то же самое значение.

# Например, если два параллельных вызова этой функции одновременно получат одно и то же значение (например, current_likes = 5),
# они оба увеличат его на 1 и попытаются записать 6. В результате один из этих обновлений будет перезаписан,
# и счетчик лайков потеряет один из прибавленных лайков.


async def GOOD_update_cache_likes_in_redis(post_id):
    """
    Поддерживает актуальность лайков в кэше
    """
    key = f"likes:{post_id}"

    try:
        # Атомарно увеличиваем значение лайков
        new_likes = await redis.incr(key)
    except Exception as e:
        # Логируем ошибку или обрабатываем ее согласно требованиям
        print(f"Ошибка при работе с Redis: {e}")
        raise

    return new_likes

# Команда INCR автоматически увеличивает значение ключа на 1. Если ключ отсутствует, она создает его со значением 1.